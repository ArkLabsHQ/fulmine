// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const cancelDelegateTasks = `-- name: CancelDelegateTasks :exec
UPDATE delegate_task
SET status = 3
WHERE status = 0 AND id IN (/*SLICE:ids*/?)
`

func (q *Queries) CancelDelegateTasks(ctx context.Context, ids []string) error {
	query := cancelDelegateTasks
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const createChainSwap = `-- name: CreateChainSwap :exec
INSERT INTO chain_swap (
    id, from_currency, to_currency, amount, status, user_lockup_tx_id, server_lockup_tx_id,
    claim_tx_id, claim_preimage, refund_tx_id, user_btc_lockup_address, error_message,
    boltz_create_response_json
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateChainSwapParams struct {
	ID                      string
	FromCurrency            string
	ToCurrency              string
	Amount                  int64
	Status                  int64
	UserLockupTxID          sql.NullString
	ServerLockupTxID        sql.NullString
	ClaimTxID               sql.NullString
	ClaimPreimage           string
	RefundTxID              sql.NullString
	UserBtcLockupAddress    sql.NullString
	ErrorMessage            sql.NullString
	BoltzCreateResponseJson sql.NullString
}

// ChainSwap queries
func (q *Queries) CreateChainSwap(ctx context.Context, arg CreateChainSwapParams) error {
	_, err := q.db.ExecContext(ctx, createChainSwap,
		arg.ID,
		arg.FromCurrency,
		arg.ToCurrency,
		arg.Amount,
		arg.Status,
		arg.UserLockupTxID,
		arg.ServerLockupTxID,
		arg.ClaimTxID,
		arg.ClaimPreimage,
		arg.RefundTxID,
		arg.UserBtcLockupAddress,
		arg.ErrorMessage,
		arg.BoltzCreateResponseJson,
	)
	return err
}

const createSwap = `-- name: CreateSwap :exec
INSERT INTO swap (
  id, amount, timestamp, to_currency, from_currency, swap_type, status, invoice, funding_tx_id, redeem_tx_id, vhtlc_id
) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
`

type CreateSwapParams struct {
	ID           string
	Amount       int64
	Timestamp    int64
	ToCurrency   string
	FromCurrency string
	SwapType     int64
	Status       int64
	Invoice      string
	FundingTxID  string
	RedeemTxID   string
	VhtlcID      string
}

// Swap queries
func (q *Queries) CreateSwap(ctx context.Context, arg CreateSwapParams) error {
	_, err := q.db.ExecContext(ctx, createSwap,
		arg.ID,
		arg.Amount,
		arg.Timestamp,
		arg.ToCurrency,
		arg.FromCurrency,
		arg.SwapType,
		arg.Status,
		arg.Invoice,
		arg.FundingTxID,
		arg.RedeemTxID,
		arg.VhtlcID,
	)
	return err
}

const deleteChainSwap = `-- name: DeleteChainSwap :exec
DELETE FROM chain_swap WHERE id = ?
`

func (q *Queries) DeleteChainSwap(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteChainSwap, id)
	return err
}

const deleteSettings = `-- name: DeleteSettings :exec
DELETE FROM settings
`

func (q *Queries) DeleteSettings(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteSettings)
	return err
}

const deleteSubscribedScript = `-- name: DeleteSubscribedScript :exec
DELETE FROM subscribed_script WHERE script = ?
`

func (q *Queries) DeleteSubscribedScript(ctx context.Context, script string) error {
	_, err := q.db.ExecContext(ctx, deleteSubscribedScript, script)
	return err
}

const deleteVtxoRollover = `-- name: DeleteVtxoRollover :exec
DELETE FROM vtxo_rollover WHERE address = ?
`

func (q *Queries) DeleteVtxoRollover(ctx context.Context, address string) error {
	_, err := q.db.ExecContext(ctx, deleteVtxoRollover, address)
	return err
}

const failDelegateTasks = `-- name: FailDelegateTasks :exec
UPDATE delegate_task
SET status = 2, fail_reason = ?
WHERE status = 0 AND id IN (/*SLICE:ids*/?)
`

type FailDelegateTasksParams struct {
	FailReason sql.NullString
	Ids        []string
}

func (q *Queries) FailDelegateTasks(ctx context.Context, arg FailDelegateTasksParams) error {
	query := failDelegateTasks
	var queryParams []interface{}
	queryParams = append(queryParams, arg.FailReason)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const getChainSwap = `-- name: GetChainSwap :one
SELECT id, from_currency, to_currency, amount, status, user_lockup_tx_id, server_lockup_tx_id, claim_tx_id, claim_preimage, refund_tx_id, user_btc_lockup_address, error_message, created_at, updated_at, boltz_create_response_json FROM chain_swap WHERE id = ?
`

func (q *Queries) GetChainSwap(ctx context.Context, id string) (ChainSwap, error) {
	row := q.db.QueryRowContext(ctx, getChainSwap, id)
	var i ChainSwap
	err := row.Scan(
		&i.ID,
		&i.FromCurrency,
		&i.ToCurrency,
		&i.Amount,
		&i.Status,
		&i.UserLockupTxID,
		&i.ServerLockupTxID,
		&i.ClaimTxID,
		&i.ClaimPreimage,
		&i.RefundTxID,
		&i.UserBtcLockupAddress,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BoltzCreateResponseJson,
	)
	return i, err
}

const getDelegateTask = `-- name: GetDelegateTask :many
SELECT
    dt.id,
    dt.intent_txid,
    dt.intent_message,
    dt.intent_proof,
    dt.fee,
    dt.delegator_public_key,
    dt.scheduled_at,
    dt.status,
    dt.fail_reason,
    dt.commitment_txid,
    dti.outpoint,
    dti.forfeit_tx
FROM delegate_task dt
LEFT JOIN delegate_task_input dti ON dt.id = dti.task_id
WHERE dt.id = ?
`

type GetDelegateTaskRow struct {
	ID                 string
	IntentTxid         string
	IntentMessage      string
	IntentProof        string
	Fee                int64
	DelegatorPublicKey string
	ScheduledAt        int64
	Status             int64
	FailReason         sql.NullString
	CommitmentTxid     sql.NullString
	Outpoint           sql.NullString
	ForfeitTx          sql.NullString
}

func (q *Queries) GetDelegateTask(ctx context.Context, id string) ([]GetDelegateTaskRow, error) {
	rows, err := q.db.QueryContext(ctx, getDelegateTask, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDelegateTaskRow
	for rows.Next() {
		var i GetDelegateTaskRow
		if err := rows.Scan(
			&i.ID,
			&i.IntentTxid,
			&i.IntentMessage,
			&i.IntentProof,
			&i.Fee,
			&i.DelegatorPublicKey,
			&i.ScheduledAt,
			&i.Status,
			&i.FailReason,
			&i.CommitmentTxid,
			&i.Outpoint,
			&i.ForfeitTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDelegateTaskInputs = `-- name: GetDelegateTaskInputs :many
SELECT outpoint FROM delegate_task_input WHERE task_id = ?
`

func (q *Queries) GetDelegateTaskInputs(ctx context.Context, taskID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDelegateTaskInputs, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var outpoint string
		if err := rows.Scan(&outpoint); err != nil {
			return nil, err
		}
		items = append(items, outpoint)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingTaskByIntentTxID = `-- name: GetPendingTaskByIntentTxID :one
SELECT id, scheduled_at FROM delegate_task WHERE status = 0 AND intent_txid = ?
`

type GetPendingTaskByIntentTxIDRow struct {
	ID          string
	ScheduledAt int64
}

func (q *Queries) GetPendingTaskByIntentTxID(ctx context.Context, intentTxid string) (GetPendingTaskByIntentTxIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPendingTaskByIntentTxID, intentTxid)
	var i GetPendingTaskByIntentTxIDRow
	err := row.Scan(&i.ID, &i.ScheduledAt)
	return i, err
}

const getPendingTaskIDsByInputs = `-- name: GetPendingTaskIDsByInputs :many
SELECT DISTINCT dt.id FROM delegate_task dt
		INNER JOIN delegate_task_input dti ON dt.id = dti.task_id
		WHERE dt.status = 0
		AND dti.outpoint IN (/*SLICE:outpoints*/?)
`

func (q *Queries) GetPendingTaskIDsByInputs(ctx context.Context, outpoints []string) ([]string, error) {
	query := getPendingTaskIDsByInputs
	var queryParams []interface{}
	if len(outpoints) > 0 {
		for _, v := range outpoints {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:outpoints*/?", strings.Repeat(",?", len(outpoints))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:outpoints*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSettings = `-- name: GetSettings :one
SELECT id, api_root, server_url, esplora_url, currency, event_server, full_node, ln_url, unit, ln_datadir, ln_type FROM settings WHERE id = 1
`

func (q *Queries) GetSettings(ctx context.Context) (Setting, error) {
	row := q.db.QueryRowContext(ctx, getSettings)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.ApiRoot,
		&i.ServerUrl,
		&i.EsploraUrl,
		&i.Currency,
		&i.EventServer,
		&i.FullNode,
		&i.LnUrl,
		&i.Unit,
		&i.LnDatadir,
		&i.LnType,
	)
	return i, err
}

const getSubscribedScript = `-- name: GetSubscribedScript :one
SELECT script FROM subscribed_script WHERE script = ?
`

func (q *Queries) GetSubscribedScript(ctx context.Context, script string) (string, error) {
	row := q.db.QueryRowContext(ctx, getSubscribedScript, script)
	err := row.Scan(&script)
	return script, err
}

const getSwap = `-- name: GetSwap :one
SELECT  swap.id, swap.amount, swap.timestamp, swap.to_currency, swap.from_currency, swap.status, swap.swap_type, swap.invoice, swap.funding_tx_id, swap.redeem_tx_id, swap.vhtlc_id,
        vhtlc.id, vhtlc.preimage_hash, vhtlc.sender, vhtlc.receiver, vhtlc.server, vhtlc.refund_locktime, vhtlc.unilateral_claim_delay_type, vhtlc.unilateral_claim_delay_value, vhtlc.unilateral_refund_delay_type, vhtlc.unilateral_refund_delay_value, vhtlc.unilateral_refund_without_receiver_delay_type, vhtlc.unilateral_refund_without_receiver_delay_value
FROM swap
  LEFT JOIN vhtlc ON swap.vhtlc_id = vhtlc.id
WHERE swap.id = ?
`

type GetSwapRow struct {
	Swap  Swap
	Vhtlc Vhtlc
}

func (q *Queries) GetSwap(ctx context.Context, id string) (GetSwapRow, error) {
	row := q.db.QueryRowContext(ctx, getSwap, id)
	var i GetSwapRow
	err := row.Scan(
		&i.Swap.ID,
		&i.Swap.Amount,
		&i.Swap.Timestamp,
		&i.Swap.ToCurrency,
		&i.Swap.FromCurrency,
		&i.Swap.Status,
		&i.Swap.SwapType,
		&i.Swap.Invoice,
		&i.Swap.FundingTxID,
		&i.Swap.RedeemTxID,
		&i.Swap.VhtlcID,
		&i.Vhtlc.ID,
		&i.Vhtlc.PreimageHash,
		&i.Vhtlc.Sender,
		&i.Vhtlc.Receiver,
		&i.Vhtlc.Server,
		&i.Vhtlc.RefundLocktime,
		&i.Vhtlc.UnilateralClaimDelayType,
		&i.Vhtlc.UnilateralClaimDelayValue,
		&i.Vhtlc.UnilateralRefundDelayType,
		&i.Vhtlc.UnilateralRefundDelayValue,
		&i.Vhtlc.UnilateralRefundWithoutReceiverDelayType,
		&i.Vhtlc.UnilateralRefundWithoutReceiverDelayValue,
	)
	return i, err
}

const getVHTLC = `-- name: GetVHTLC :one
SELECT id, preimage_hash, sender, receiver, server, refund_locktime, unilateral_claim_delay_type, unilateral_claim_delay_value, unilateral_refund_delay_type, unilateral_refund_delay_value, unilateral_refund_without_receiver_delay_type, unilateral_refund_without_receiver_delay_value FROM vhtlc WHERE id = ?
`

func (q *Queries) GetVHTLC(ctx context.Context, id string) (Vhtlc, error) {
	row := q.db.QueryRowContext(ctx, getVHTLC, id)
	var i Vhtlc
	err := row.Scan(
		&i.ID,
		&i.PreimageHash,
		&i.Sender,
		&i.Receiver,
		&i.Server,
		&i.RefundLocktime,
		&i.UnilateralClaimDelayType,
		&i.UnilateralClaimDelayValue,
		&i.UnilateralRefundDelayType,
		&i.UnilateralRefundDelayValue,
		&i.UnilateralRefundWithoutReceiverDelayType,
		&i.UnilateralRefundWithoutReceiverDelayValue,
	)
	return i, err
}

const getVtxoRollover = `-- name: GetVtxoRollover :one
SELECT address, taproot_tree, destination_address FROM vtxo_rollover WHERE address = ?
`

func (q *Queries) GetVtxoRollover(ctx context.Context, address string) (VtxoRollover, error) {
	row := q.db.QueryRowContext(ctx, getVtxoRollover, address)
	var i VtxoRollover
	err := row.Scan(&i.Address, &i.TaprootTree, &i.DestinationAddress)
	return i, err
}

const insertDelegateTask = `-- name: InsertDelegateTask :exec
INSERT INTO delegate_task (id, intent_txid, intent_message, intent_proof, fee, delegator_public_key, scheduled_at, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertDelegateTaskParams struct {
	ID                 string
	IntentTxid         string
	IntentMessage      string
	IntentProof        string
	Fee                int64
	DelegatorPublicKey string
	ScheduledAt        int64
	Status             int64
}

func (q *Queries) InsertDelegateTask(ctx context.Context, arg InsertDelegateTaskParams) error {
	_, err := q.db.ExecContext(ctx, insertDelegateTask,
		arg.ID,
		arg.IntentTxid,
		arg.IntentMessage,
		arg.IntentProof,
		arg.Fee,
		arg.DelegatorPublicKey,
		arg.ScheduledAt,
		arg.Status,
	)
	return err
}

const insertDelegateTaskInput = `-- name: InsertDelegateTaskInput :exec
INSERT INTO delegate_task_input (task_id, outpoint, forfeit_tx)
VALUES (?, ?, ?)
ON CONFLICT(task_id, outpoint) DO UPDATE SET
    forfeit_tx = excluded.forfeit_tx
`

type InsertDelegateTaskInputParams struct {
	TaskID    string
	Outpoint  string
	ForfeitTx sql.NullString
}

func (q *Queries) InsertDelegateTaskInput(ctx context.Context, arg InsertDelegateTaskInputParams) error {
	_, err := q.db.ExecContext(ctx, insertDelegateTaskInput, arg.TaskID, arg.Outpoint, arg.ForfeitTx)
	return err
}

const insertSubscribedScript = `-- name: InsertSubscribedScript :exec
INSERT INTO subscribed_script (script)
VALUES (?)
`

// SubscribedScript queries
func (q *Queries) InsertSubscribedScript(ctx context.Context, script string) error {
	_, err := q.db.ExecContext(ctx, insertSubscribedScript, script)
	return err
}

const insertVHTLC = `-- name: InsertVHTLC :exec
INSERT INTO vhtlc (
    id, preimage_hash, sender, receiver, server, refund_locktime,
    unilateral_claim_delay_type, unilateral_claim_delay_value,
    unilateral_refund_delay_type, unilateral_refund_delay_value,
    unilateral_refund_without_receiver_delay_type, unilateral_refund_without_receiver_delay_value
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertVHTLCParams struct {
	ID                                        string
	PreimageHash                              string
	Sender                                    string
	Receiver                                  string
	Server                                    string
	RefundLocktime                            int64
	UnilateralClaimDelayType                  int64
	UnilateralClaimDelayValue                 int64
	UnilateralRefundDelayType                 int64
	UnilateralRefundDelayValue                int64
	UnilateralRefundWithoutReceiverDelayType  int64
	UnilateralRefundWithoutReceiverDelayValue int64
}

// VHTLC queries
func (q *Queries) InsertVHTLC(ctx context.Context, arg InsertVHTLCParams) error {
	_, err := q.db.ExecContext(ctx, insertVHTLC,
		arg.ID,
		arg.PreimageHash,
		arg.Sender,
		arg.Receiver,
		arg.Server,
		arg.RefundLocktime,
		arg.UnilateralClaimDelayType,
		arg.UnilateralClaimDelayValue,
		arg.UnilateralRefundDelayType,
		arg.UnilateralRefundDelayValue,
		arg.UnilateralRefundWithoutReceiverDelayType,
		arg.UnilateralRefundWithoutReceiverDelayValue,
	)
	return err
}

const listChainSwaps = `-- name: ListChainSwaps :many
SELECT id, from_currency, to_currency, amount, status, user_lockup_tx_id, server_lockup_tx_id, claim_tx_id, claim_preimage, refund_tx_id, user_btc_lockup_address, error_message, created_at, updated_at, boltz_create_response_json FROM chain_swap ORDER BY created_at DESC
`

func (q *Queries) ListChainSwaps(ctx context.Context) ([]ChainSwap, error) {
	rows, err := q.db.QueryContext(ctx, listChainSwaps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChainSwap
	for rows.Next() {
		var i ChainSwap
		if err := rows.Scan(
			&i.ID,
			&i.FromCurrency,
			&i.ToCurrency,
			&i.Amount,
			&i.Status,
			&i.UserLockupTxID,
			&i.ServerLockupTxID,
			&i.ClaimTxID,
			&i.ClaimPreimage,
			&i.RefundTxID,
			&i.UserBtcLockupAddress,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BoltzCreateResponseJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChainSwapsByIDs = `-- name: ListChainSwapsByIDs :many
SELECT id, from_currency, to_currency, amount, status, user_lockup_tx_id, server_lockup_tx_id, claim_tx_id, claim_preimage, refund_tx_id, user_btc_lockup_address, error_message, created_at, updated_at, boltz_create_response_json FROM chain_swap WHERE id IN (/*SLICE:ids*/?) ORDER BY created_at DESC
`

func (q *Queries) ListChainSwapsByIDs(ctx context.Context, ids []string) ([]ChainSwap, error) {
	query := listChainSwapsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChainSwap
	for rows.Next() {
		var i ChainSwap
		if err := rows.Scan(
			&i.ID,
			&i.FromCurrency,
			&i.ToCurrency,
			&i.Amount,
			&i.Status,
			&i.UserLockupTxID,
			&i.ServerLockupTxID,
			&i.ClaimTxID,
			&i.ClaimPreimage,
			&i.RefundTxID,
			&i.UserBtcLockupAddress,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BoltzCreateResponseJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChainSwapsByStatus = `-- name: ListChainSwapsByStatus :many
SELECT id, from_currency, to_currency, amount, status, user_lockup_tx_id, server_lockup_tx_id, claim_tx_id, claim_preimage, refund_tx_id, user_btc_lockup_address, error_message, created_at, updated_at, boltz_create_response_json FROM chain_swap WHERE status = ? ORDER BY created_at DESC
`

func (q *Queries) ListChainSwapsByStatus(ctx context.Context, status int64) ([]ChainSwap, error) {
	rows, err := q.db.QueryContext(ctx, listChainSwapsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChainSwap
	for rows.Next() {
		var i ChainSwap
		if err := rows.Scan(
			&i.ID,
			&i.FromCurrency,
			&i.ToCurrency,
			&i.Amount,
			&i.Status,
			&i.UserLockupTxID,
			&i.ServerLockupTxID,
			&i.ClaimTxID,
			&i.ClaimPreimage,
			&i.RefundTxID,
			&i.UserBtcLockupAddress,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BoltzCreateResponseJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDelegateTaskPending = `-- name: ListDelegateTaskPending :many
SELECT id, scheduled_at FROM delegate_task WHERE status = 0
`

type ListDelegateTaskPendingRow struct {
	ID          string
	ScheduledAt int64
}

func (q *Queries) ListDelegateTaskPending(ctx context.Context) ([]ListDelegateTaskPendingRow, error) {
	rows, err := q.db.QueryContext(ctx, listDelegateTaskPending)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDelegateTaskPendingRow
	for rows.Next() {
		var i ListDelegateTaskPendingRow
		if err := rows.Scan(&i.ID, &i.ScheduledAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDelegateTasks = `-- name: ListDelegateTasks :many
SELECT
    dt.id,
    dt.intent_txid,
    dt.intent_message,
    dt.intent_proof,
    dt.fee,
    dt.delegator_public_key,
    dt.scheduled_at,
    dt.status,
    dt.fail_reason,
    dt.commitment_txid,
    dti.outpoint,
    dti.forfeit_tx
FROM delegate_task dt
LEFT JOIN delegate_task_input dti ON dt.id = dti.task_id
WHERE dt.status = ?
ORDER BY dt.scheduled_at DESC
LIMIT ? OFFSET ?
`

type ListDelegateTasksParams struct {
	Status int64
	Limit  int64
	Offset int64
}

type ListDelegateTasksRow struct {
	ID                 string
	IntentTxid         string
	IntentMessage      string
	IntentProof        string
	Fee                int64
	DelegatorPublicKey string
	ScheduledAt        int64
	Status             int64
	FailReason         sql.NullString
	CommitmentTxid     sql.NullString
	Outpoint           sql.NullString
	ForfeitTx          sql.NullString
}

func (q *Queries) ListDelegateTasks(ctx context.Context, arg ListDelegateTasksParams) ([]ListDelegateTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, listDelegateTasks, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDelegateTasksRow
	for rows.Next() {
		var i ListDelegateTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.IntentTxid,
			&i.IntentMessage,
			&i.IntentProof,
			&i.Fee,
			&i.DelegatorPublicKey,
			&i.ScheduledAt,
			&i.Status,
			&i.FailReason,
			&i.CommitmentTxid,
			&i.Outpoint,
			&i.ForfeitTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscribedScript = `-- name: ListSubscribedScript :many
SELECT script FROM subscribed_script
`

func (q *Queries) ListSubscribedScript(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listSubscribedScript)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var script string
		if err := rows.Scan(&script); err != nil {
			return nil, err
		}
		items = append(items, script)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSwaps = `-- name: ListSwaps :many
SELECT  swap.id, swap.amount, swap.timestamp, swap.to_currency, swap.from_currency, swap.status, swap.swap_type, swap.invoice, swap.funding_tx_id, swap.redeem_tx_id, swap.vhtlc_id, vhtlc.id, vhtlc.preimage_hash, vhtlc.sender, vhtlc.receiver, vhtlc.server, vhtlc.refund_locktime, vhtlc.unilateral_claim_delay_type, vhtlc.unilateral_claim_delay_value, vhtlc.unilateral_refund_delay_type, vhtlc.unilateral_refund_delay_value, vhtlc.unilateral_refund_without_receiver_delay_type, vhtlc.unilateral_refund_without_receiver_delay_value
FROM swap
  LEFT JOIN vhtlc ON swap.vhtlc_id = vhtlc.id
`

type ListSwapsRow struct {
	Swap  Swap
	Vhtlc Vhtlc
}

func (q *Queries) ListSwaps(ctx context.Context) ([]ListSwapsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSwaps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSwapsRow
	for rows.Next() {
		var i ListSwapsRow
		if err := rows.Scan(
			&i.Swap.ID,
			&i.Swap.Amount,
			&i.Swap.Timestamp,
			&i.Swap.ToCurrency,
			&i.Swap.FromCurrency,
			&i.Swap.Status,
			&i.Swap.SwapType,
			&i.Swap.Invoice,
			&i.Swap.FundingTxID,
			&i.Swap.RedeemTxID,
			&i.Swap.VhtlcID,
			&i.Vhtlc.ID,
			&i.Vhtlc.PreimageHash,
			&i.Vhtlc.Sender,
			&i.Vhtlc.Receiver,
			&i.Vhtlc.Server,
			&i.Vhtlc.RefundLocktime,
			&i.Vhtlc.UnilateralClaimDelayType,
			&i.Vhtlc.UnilateralClaimDelayValue,
			&i.Vhtlc.UnilateralRefundDelayType,
			&i.Vhtlc.UnilateralRefundDelayValue,
			&i.Vhtlc.UnilateralRefundWithoutReceiverDelayType,
			&i.Vhtlc.UnilateralRefundWithoutReceiverDelayValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVHTLC = `-- name: ListVHTLC :many
SELECT id, preimage_hash, sender, receiver, server, refund_locktime, unilateral_claim_delay_type, unilateral_claim_delay_value, unilateral_refund_delay_type, unilateral_refund_delay_value, unilateral_refund_without_receiver_delay_type, unilateral_refund_without_receiver_delay_value FROM vhtlc
`

func (q *Queries) ListVHTLC(ctx context.Context) ([]Vhtlc, error) {
	rows, err := q.db.QueryContext(ctx, listVHTLC)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vhtlc
	for rows.Next() {
		var i Vhtlc
		if err := rows.Scan(
			&i.ID,
			&i.PreimageHash,
			&i.Sender,
			&i.Receiver,
			&i.Server,
			&i.RefundLocktime,
			&i.UnilateralClaimDelayType,
			&i.UnilateralClaimDelayValue,
			&i.UnilateralRefundDelayType,
			&i.UnilateralRefundDelayValue,
			&i.UnilateralRefundWithoutReceiverDelayType,
			&i.UnilateralRefundWithoutReceiverDelayValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVtxoRollover = `-- name: ListVtxoRollover :many
SELECT address, taproot_tree, destination_address FROM vtxo_rollover
`

func (q *Queries) ListVtxoRollover(ctx context.Context) ([]VtxoRollover, error) {
	rows, err := q.db.QueryContext(ctx, listVtxoRollover)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VtxoRollover
	for rows.Next() {
		var i VtxoRollover
		if err := rows.Scan(&i.Address, &i.TaprootTree, &i.DestinationAddress); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const successDelegateTasks = `-- name: SuccessDelegateTasks :exec
UPDATE delegate_task
SET status = 1, commitment_txid = ?
WHERE status = 0 AND id IN (/*SLICE:ids*/?)
`

type SuccessDelegateTasksParams struct {
	CommitmentTxid sql.NullString
	Ids            []string
}

func (q *Queries) SuccessDelegateTasks(ctx context.Context, arg SuccessDelegateTasksParams) error {
	query := successDelegateTasks
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CommitmentTxid)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const updateChainSwap = `-- name: UpdateChainSwap :exec
UPDATE chain_swap
SET status = ?,
    user_lockup_tx_id = ?,
    server_lockup_tx_id = ?,
    claim_tx_id = ?,
    refund_tx_id = ?,
    error_message = ?,
    boltz_create_response_json = ?,
    updated_at = strftime('%s', 'now')
WHERE id = ?
`

type UpdateChainSwapParams struct {
	Status                  int64
	UserLockupTxID          sql.NullString
	ServerLockupTxID        sql.NullString
	ClaimTxID               sql.NullString
	RefundTxID              sql.NullString
	ErrorMessage            sql.NullString
	BoltzCreateResponseJson sql.NullString
	ID                      string
}

func (q *Queries) UpdateChainSwap(ctx context.Context, arg UpdateChainSwapParams) error {
	_, err := q.db.ExecContext(ctx, updateChainSwap,
		arg.Status,
		arg.UserLockupTxID,
		arg.ServerLockupTxID,
		arg.ClaimTxID,
		arg.RefundTxID,
		arg.ErrorMessage,
		arg.BoltzCreateResponseJson,
		arg.ID,
	)
	return err
}

const updateSwap = `-- name: UpdateSwap :exec
UPDATE swap 
SET status = ?,
redeem_tx_id = ?
WHERE id = ?
`

type UpdateSwapParams struct {
	Status     int64
	RedeemTxID string
	ID         string
}

func (q *Queries) UpdateSwap(ctx context.Context, arg UpdateSwapParams) error {
	_, err := q.db.ExecContext(ctx, updateSwap, arg.Status, arg.RedeemTxID, arg.ID)
	return err
}

const upsertSettings = `-- name: UpsertSettings :exec
INSERT INTO settings (id, api_root, server_url, esplora_url, currency, event_server, full_node, unit, ln_url, ln_datadir, ln_type)
VALUES (1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    api_root = excluded.api_root,
    server_url = excluded.server_url,
    esplora_url = excluded.esplora_url,
    currency = excluded.currency,
    event_server = excluded.event_server,
    full_node = excluded.full_node,
    unit = excluded.unit,
    ln_url = excluded.ln_url,
    ln_datadir = excluded.ln_datadir,
    ln_type = excluded.ln_type
`

type UpsertSettingsParams struct {
	ApiRoot     string
	ServerUrl   string
	EsploraUrl  sql.NullString
	Currency    string
	EventServer string
	FullNode    string
	Unit        string
	LnUrl       sql.NullString
	LnDatadir   sql.NullString
	LnType      sql.NullInt64
}

// Settings queries
func (q *Queries) UpsertSettings(ctx context.Context, arg UpsertSettingsParams) error {
	_, err := q.db.ExecContext(ctx, upsertSettings,
		arg.ApiRoot,
		arg.ServerUrl,
		arg.EsploraUrl,
		arg.Currency,
		arg.EventServer,
		arg.FullNode,
		arg.Unit,
		arg.LnUrl,
		arg.LnDatadir,
		arg.LnType,
	)
	return err
}

const upsertVtxoRollover = `-- name: UpsertVtxoRollover :exec
INSERT INTO vtxo_rollover (address, taproot_tree, destination_address) VALUES (?, ?, ?)
ON CONFLICT(address) DO UPDATE SET
    taproot_tree = excluded.taproot_tree,
    destination_address = excluded.destination_address
`

type UpsertVtxoRolloverParams struct {
	Address            string
	TaprootTree        string
	DestinationAddress string
}

// VtxoRollover queries
func (q *Queries) UpsertVtxoRollover(ctx context.Context, arg UpsertVtxoRolloverParams) error {
	_, err := q.db.ExecContext(ctx, upsertVtxoRollover, arg.Address, arg.TaprootTree, arg.DestinationAddress)
	return err
}
