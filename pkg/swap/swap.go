package swap

import (
	"context"
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/ArkLabsHQ/fulmine/pkg/boltz"
	"github.com/ArkLabsHQ/fulmine/pkg/vhtlc"
	"github.com/ark-network/ark/common"
	"github.com/ark-network/ark/common/tree"
	arksdk "github.com/ark-network/ark/pkg/client-sdk"
	"github.com/ark-network/ark/pkg/client-sdk/client"
	"github.com/btcsuite/btcd/btcutil/psbt"
	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/txscript"
	"github.com/btcsuite/btcd/wire"
	"github.com/btcsuite/btcwallet/waddrmgr"
	"github.com/ccoveille/go-safecast"
	"github.com/decred/dcrd/dcrec/secp256k1/v4"
	log "github.com/sirupsen/logrus"
)

type SwapHandler struct {
	arkClient        arksdk.ArkClient
	transportClient  client.TransportClient
	boltzSvc         *boltz.Api
	onchainPublicKey *secp256k1.PublicKey
}

func NewSwapHandler(arkClient arksdk.ArkClient, transportClient client.TransportClient, onchainPublicKey *secp256k1.PublicKey, boltzUrl string, boltzWsUrl string) *SwapHandler {
	return &SwapHandler{
		arkClient:        arkClient,
		transportClient:  transportClient,
		boltzSvc:         &boltz.Api{URL: boltzUrl, WSURL: boltzWsUrl},
		onchainPublicKey: onchainPublicKey,
	}
}

func (h *SwapHandler) PayInvoice(ctx context.Context, invoice string, pubkey []byte) (string, error) {
	if len(invoice) <= 0 {
		return "", fmt.Errorf("missing invoice")
	}

	return h.submarineSwap(ctx, 0, invoice, pubkey)
}

func (h *SwapHandler) GetInvoice(ctx context.Context, amount uint64, pubkey []byte) (string, error) {
	preimage := make([]byte, 32)
	if _, err := rand.Read(preimage); err != nil {
		return "", fmt.Errorf("failed to generate preimage: %w", err)
	}

	return h.reverseSwap(ctx, amount, preimage, pubkey)
}

// swap takes care of interacting with the Boltz server to make a submarine swap.
// The function can be used by passing either an amount or an invoice. The args are mutually exclusive.
// When passing an amount, the invoice is generated by us, otherwise it means its generated by
// somebody else. In any case, we fund the VHTLC and make sure that it succeeds before returning,
// otherwise the VHTLC is refunded if necessary.

func (h *SwapHandler) submarineSwap(ctx context.Context, amount uint64, invoice string, pubkey []byte) (string, error) {
	if amount > 0 && invoice != "" {
		return "", errors.New("amount and invoice cannot be specified at the same time")
	}

	var preimageHash []byte

	amount, preimageHash, err := DecodeInvoice(invoice)
	fmt.Printf("amount: %d, preimageHash: %x\n", amount, preimageHash)
	if err != nil {
		return "", fmt.Errorf("failed to decode invoice: %v", err)
	}

	fmt.Printf("boltzScv %+v\n", h.boltzSvc)
	// Create the swap
	swap, err := h.boltzSvc.CreateSwap(boltz.CreateSwapRequest{
		From:            boltz.CurrencyArk,
		To:              boltz.CurrencyBtc,
		Invoice:         invoice,
		RefundPublicKey: hex.EncodeToString(pubkey),
	})
	if err != nil {
		return "", fmt.Errorf("failed to make submarine swap: %v", err)
	}

	receiverPubkey, err := parsePubkey(swap.ClaimPublicKey)
	if err != nil {
		return "", fmt.Errorf("invalid claim pubkey: %v", err)
	}

	address, opts, err := h.GetVHTLC(
		ctx,
		receiverPubkey,
		nil,
		preimageHash,
		nil,
		&common.RelativeLocktime{Type: common.LocktimeTypeBlock, Value: swap.TimeoutBlockHeights.UnilateralClaim},
		&common.RelativeLocktime{Type: common.LocktimeTypeBlock, Value: swap.TimeoutBlockHeights.UnilateralRefund},
		&common.RelativeLocktime{Type: common.LocktimeTypeBlock, Value: swap.TimeoutBlockHeights.UnilateralRefundWithoutReceiver},
	)
	if err != nil {
		return "", fmt.Errorf("failed to verify vHTLC: %v", err)
	}
	if swap.Address != address {
		return "", fmt.Errorf("boltz is trying to scam us, vHTLCs do not match")
	}

	// Fund the VHTLC
	receivers := []arksdk.Receiver{arksdk.NewBitcoinReceiver(swap.Address, amount)}
	txid, err := h.arkClient.SendOffChain(ctx, false, receivers, true)
	if err != nil {
		return "", fmt.Errorf("failed to pay to vHTLC address: %v", err)
	}

	ws := h.boltzSvc.NewWebsocket()
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	err = ws.Connect()
	for err != nil {
		log.WithError(err).Warn("failed to connect to boltz websocket")
		time.Sleep(time.Second)
		log.Debug("reconnecting...")
		err = ws.Connect()
		if ctx.Err() != nil {
			return "", fmt.Errorf("timeout while connecting to websocket: %v", ctx.Err())
		}
	}

	err = ws.Subscribe([]string{swap.Id})
	for err != nil {
		log.WithError(err).Warn("failed to subscribe for swap events")
		time.Sleep(time.Second)
		log.Debug("retrying...")
		err = ws.Subscribe([]string{swap.Id})
	}

	for update := range ws.Updates {
		parsedStatus := boltz.ParseEvent(update.Status)

		switch parsedStatus {
		case boltz.TransactionLockupFailed, boltz.InvoiceFailedToPay:
			// Refund the VHTLC if the swap fails
			withReceiver := true
			txid, err := h.RefundVHTLC(
				context.Background(), swap.Id, hex.EncodeToString(preimageHash), withReceiver, address, *opts,
			)
			if err != nil {
				return "", fmt.Errorf("failed to refund vHTLC: %s", err)
			}

			return "", fmt.Errorf("something went wrong, the vhtlc was refunded %s", txid)
		case boltz.TransactionClaimed, boltz.InvoiceSet:
			// Nothing left to do, return the VHTLC funding txid
			return txid, nil
		}
	}

	return "", fmt.Errorf("something went wrong")
}

func (h *SwapHandler) GetVHTLC(
	ctx context.Context,
	receiverPubkey, senderPubkey *secp256k1.PublicKey,
	preimageHash []byte,
	refundLocktimeParam *common.AbsoluteLocktime,
	unilateralClaimDelayParam *common.RelativeLocktime,
	unilateralRefundDelayParam *common.RelativeLocktime,
	unilateralRefundWithoutReceiverDelayParam *common.RelativeLocktime,
) (string, *vhtlc.Opts, error) {

	receiverPubkeySet := receiverPubkey != nil
	senderPubkeySet := senderPubkey != nil
	if receiverPubkeySet == senderPubkeySet {
		return "", nil, fmt.Errorf("only one of receiver and sender pubkey must be set")
	}
	if !receiverPubkeySet {
		receiverPubkey = h.onchainPublicKey
	}
	if !senderPubkeySet {
		senderPubkey = h.onchainPublicKey
	}

	offchainAddr, _, err := h.arkClient.Receive(ctx)
	if err != nil {
		return "", nil, err
	}

	decodedAddr, err := common.DecodeAddress(offchainAddr)
	if err != nil {
		return "", nil, err
	}

	// Default values if not provided
	refundLocktime := common.AbsoluteLocktime(80 * 600) // 80 blocks
	if refundLocktimeParam != nil {
		refundLocktime = *refundLocktimeParam
	}

	unilateralClaimDelay := common.RelativeLocktime{
		Type:  common.LocktimeTypeSecond,
		Value: 512, //60 * 12, // 12 hours
	}
	if unilateralClaimDelayParam != nil {
		unilateralClaimDelay = *unilateralClaimDelayParam
	}

	unilateralRefundDelay := common.RelativeLocktime{
		Type:  common.LocktimeTypeSecond,
		Value: 1024, //60 * 24, // 24 hours
	}
	if unilateralRefundDelayParam != nil {
		unilateralRefundDelay = *unilateralRefundDelayParam
	}

	unilateralRefundWithoutReceiverDelay := common.RelativeLocktime{
		Type:  common.LocktimeTypeBlock,
		Value: 224, // 224 blocks
	}
	if unilateralRefundWithoutReceiverDelayParam != nil {
		unilateralRefundWithoutReceiverDelay = *unilateralRefundWithoutReceiverDelayParam
	}

	opts := vhtlc.Opts{
		Sender:                               senderPubkey,
		Receiver:                             receiverPubkey,
		Server:                               decodedAddr.Server,
		PreimageHash:                         preimageHash,
		RefundLocktime:                       refundLocktime,
		UnilateralClaimDelay:                 unilateralClaimDelay,
		UnilateralRefundDelay:                unilateralRefundDelay,
		UnilateralRefundWithoutReceiverDelay: unilateralRefundWithoutReceiverDelay,
	}
	vtxoScript, err := vhtlc.NewVHTLCScript(opts)
	if err != nil {
		return "", nil, err
	}

	tapKey, _, err := vtxoScript.TapTree()
	if err != nil {
		return "", nil, err
	}

	addr := &common.Address{
		HRP:        decodedAddr.HRP,
		Server:     decodedAddr.Server,
		VtxoTapKey: tapKey,
	}
	encodedAddr, err := addr.Encode()
	if err != nil {
		return "", nil, err
	}

	return encodedAddr, &opts, nil
}

func (h *SwapHandler) RefundVHTLC(ctx context.Context, swapId, preimageHash string, withReceiver bool, vhtlcAddress string, vhtlcOpt vhtlc.Opts) (string, error) {
	vtxos, err := h.ListVHTLC(ctx, vhtlcAddress)
	if err != nil {
		return "", err
	}

	if len(vtxos) == 0 {
		return "", fmt.Errorf("no vhtlc found")
	}

	vtxo := vtxos[0]

	vtxoTxHash, err := chainhash.NewHashFromStr(vtxo.Txid)
	if err != nil {
		return "", err
	}

	vtxoOutpoint := &wire.OutPoint{
		Hash:  *vtxoTxHash,
		Index: vtxo.VOut,
	}

	vtxoScript, err := vhtlc.NewVHTLCScript(vhtlcOpt)
	if err != nil {
		return "", err
	}

	var refundClosure tree.Closure
	refundClosure = vtxoScript.RefundWithoutReceiverClosure
	if withReceiver {
		refundClosure = vtxoScript.RefundClosure
	}
	refundWitnessSize := refundClosure.WitnessSize()
	refundScript, err := refundClosure.Script()
	if err != nil {
		return "", err
	}

	_, tapTree, err := vtxoScript.TapTree()
	if err != nil {
		return "", err
	}

	refundLeafProof, err := tapTree.GetTaprootMerkleProof(
		txscript.NewBaseTapLeaf(refundScript).TapHash(),
	)
	if err != nil {
		return "", err
	}

	ctrlBlock, err := txscript.ParseControlBlock(refundLeafProof.ControlBlock)
	if err != nil {
		return "", err
	}

	dest, err := txscript.PayToTaprootScript(vhtlcOpt.Sender)
	if err != nil {
		return "", err
	}

	amount, err := safecast.ToInt64(vtxo.Amount)
	if err != nil {
		return "", err
	}

	refundTx, err := tree.BuildRedeemTx(
		[]common.VtxoInput{
			{
				RevealedTapscripts: vtxoScript.GetRevealedTapscripts(),
				Outpoint:           vtxoOutpoint,
				Amount:             amount,
				WitnessSize:        refundWitnessSize,
				Tapscript: &waddrmgr.Tapscript{
					ControlBlock:   ctrlBlock,
					RevealedScript: refundScript,
				},
			},
		},
		[]*wire.TxOut{
			{
				Value:    amount,
				PkScript: dest,
			},
		},
	)
	if err != nil {
		return "", err
	}

	refundPtx, err := psbt.NewFromRawBytes(strings.NewReader(refundTx), true)
	if err != nil {
		return "", err
	}

	txid := refundPtx.UnsignedTx.TxHash().String()

	refundTx, err = refundPtx.B64Encode()
	if err != nil {
		return "", err
	}

	signedRefundTx, err := h.arkClient.SignTransaction(ctx, refundTx)
	if err != nil {
		return "", err
	}

	if withReceiver {
		signedRefundTx, err = h.boltzRefundSwap(swapId, signedRefundTx)
		if err != nil {
			return "", err
		}
	}

	if _, _, err := h.transportClient.SubmitRedeemTx(ctx, signedRefundTx); err != nil {
		return "", err
	}

	return txid, nil
}

func (h *SwapHandler) boltzRefundSwap(swapId, refundTx string) (string, error) {
	tx, err := h.boltzSvc.RefundSubmarine(swapId, boltz.RefundSwapRequest{
		Transaction: refundTx,
	})
	if err != nil {
		return "", err
	}

	return tx.Transaction, nil
}

// reverseSwap takes care of interacting with the Boltz server to make a reverse submarine swap.
// Passing a preimage to this function means that the invoice generated by Boltz is expected
// to be paid by somebody else, and therefore the swap status is watched before claiming the funds
// locked in the VHTLC.
// When the preimage is empty, the invoice returned by Boltz is expected to be paid by us, the preimage
// is revealed and the funds locked in the VHTLC can be claimed without checking the swap status.
func (h *SwapHandler) reverseSwap(ctx context.Context, amount uint64, preimage, myPubkey []byte) (string, error) {
	var preimageHash []byte
	if len(preimage) > 0 {
		buf := sha256.Sum256(preimage)
		preimageHash = buf[:]
	}

	// make swap
	swap, err := h.boltzSvc.CreateReverseSwap(boltz.CreateReverseSwapRequest{
		From:           boltz.CurrencyBtc,
		To:             boltz.CurrencyArk,
		InvoiceAmount:  amount,
		ClaimPublicKey: hex.EncodeToString(myPubkey),
		PreimageHash:   hex.EncodeToString(preimageHash),
	})
	if err != nil {
		return "", fmt.Errorf("failed to make reverse submarine swap: %v", err)
	}

	// verify vHTLC
	senderPubkey, err := parsePubkey(swap.RefundPublicKey)
	if err != nil {
		return "", fmt.Errorf("invalid refund pubkey: %v", err)
	}

	// verify preimage hash and invoice amount
	invoiceAmount, gotPreimageHash, err := DecodeInvoice(swap.Invoice)
	if err != nil {
		return "", fmt.Errorf("failed to decode invoice: %v", err)
	}
	if len(preimage) == 0 {
		preimageHash = gotPreimageHash
		fmt.Printf("avoind linting error: %x\n", preimageHash)
	}
	if invoiceAmount != amount {
		return "", fmt.Errorf("invalid invoice amount: expected %d, got %d", amount, invoiceAmount)
	}

	vhtlcAddress, vhtlcOpts, err := h.GetVHTLC(
		ctx,
		nil,
		senderPubkey,
		gotPreimageHash,
		nil,
		&common.RelativeLocktime{Type: common.LocktimeTypeBlock, Value: swap.TimeoutBlockHeights.UnilateralClaim},
		&common.RelativeLocktime{Type: common.LocktimeTypeBlock, Value: swap.TimeoutBlockHeights.UnilateralRefund},
		&common.RelativeLocktime{Type: common.LocktimeTypeBlock, Value: swap.TimeoutBlockHeights.UnilateralRefundWithoutReceiver},
	)
	if err != nil {
		return "", fmt.Errorf("failed to verify vHTLC: %v", err)
	}

	if swap.LockupAddress != vhtlcAddress {
		return "", fmt.Errorf("boltz is trying to scam us, vHTLCs do not match")
	}

	go func() {
		// Wait until invoice is paid then proceed with claiming the VHTLC

		ws := h.boltzSvc.NewWebsocket()
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		err = ws.Connect()
		for err != nil {
			log.WithError(err).Warn("failed to connect to boltz websocket")
			time.Sleep(time.Second)
			log.Debug("reconnecting...")
			err = ws.Connect()
			if ctx.Err() != nil {
				log.Warnf("timeout while connecting to websocket: %v", ctx.Err())
				return
			}
		}

		err = ws.Subscribe([]string{swap.Id})
		for err != nil {
			log.WithError(err).Warn("failed to subscribe for swap events")
			time.Sleep(time.Second)
			log.Debug("retrying...")
			err = ws.Subscribe([]string{swap.Id})
		}

		for update := range ws.Updates {
			fmt.Printf("WS update: %+v\n", update)
			parsedStatus := boltz.ParseEvent(update.Status)

			confirmed := false
			switch parsedStatus {
			case boltz.InvoiceSettled:
				confirmed = true
			case boltz.InvoiceFailedToPay, boltz.TransactionFailed, boltz.TransactionLockupFailed:
				log.Warnf("something went wrong: %s", update.Status)
				return
			}
			if confirmed {
				fmt.Println("claiming VHTLC with preimage")
				fmt.Println(h.ClaimVHTLC(ctx, preimage, vhtlcAddress, *vhtlcOpts))
				break
			}
		}
	}()

	return swap.Invoice, nil
}

func (h *SwapHandler) ClaimVHTLC(ctx context.Context, preimage []byte, vhtlcAddress string, vhtlcOpts vhtlc.Opts) (string, error) {

	vtxos, err := h.ListVHTLC(ctx, vhtlcAddress)
	if err != nil {
		return "", err
	}

	if len(vtxos) == 0 {
		return "", fmt.Errorf("no vhtlc found")
	}

	vtxo := vtxos[0]

	vtxoTxHash, err := chainhash.NewHashFromStr(vtxo.Txid)
	if err != nil {
		return "", err
	}

	vtxoOutpoint := &wire.OutPoint{
		Hash:  *vtxoTxHash,
		Index: vtxo.VOut,
	}

	vtxoScript, err := vhtlc.NewVHTLCScript(vhtlcOpts)
	if err != nil {
		return "", err
	}

	claimClosure := vtxoScript.ClaimClosure
	claimWitnessSize := claimClosure.WitnessSize(len(preimage))
	claimScript, err := claimClosure.Script()
	if err != nil {
		return "", err
	}

	_, tapTree, err := vtxoScript.TapTree()
	if err != nil {
		return "", err
	}

	claimLeafProof, err := tapTree.GetTaprootMerkleProof(
		txscript.NewBaseTapLeaf(claimScript).TapHash(),
	)
	if err != nil {
		return "", err
	}

	ctrlBlock, err := txscript.ParseControlBlock(claimLeafProof.ControlBlock)
	if err != nil {
		return "", err
	}

	// self send output
	// TODO: Verify
	myAddr, _, err := h.arkClient.Receive(ctx)
	if err != nil {
		return "", err
	}

	decodedAddr, err := common.DecodeAddress(myAddr)
	if err != nil {
		return "", err
	}

	pkScript, err := common.P2TRScript(decodedAddr.VtxoTapKey)
	if err != nil {
		return "", err
	}

	amount, err := safecast.ToInt64(vtxo.Amount)
	if err != nil {
		return "", err
	}

	redeemTx, err := tree.BuildRedeemTx(
		[]common.VtxoInput{
			{
				RevealedTapscripts: vtxoScript.GetRevealedTapscripts(),
				Outpoint:           vtxoOutpoint,
				Amount:             amount,
				WitnessSize:        claimWitnessSize,
				Tapscript: &waddrmgr.Tapscript{
					ControlBlock:   ctrlBlock,
					RevealedScript: claimScript,
				},
			},
		},
		[]*wire.TxOut{
			{
				Value:    amount,
				PkScript: pkScript,
			},
		},
	)
	if err != nil {
		return "", err
	}

	redeemPtx, err := psbt.NewFromRawBytes(strings.NewReader(redeemTx), true)
	if err != nil {
		return "", err
	}

	if err := tree.AddConditionWitness(0, redeemPtx, wire.TxWitness{preimage}); err != nil {
		return "", err
	}

	txid := redeemPtx.UnsignedTx.TxHash().String()

	redeemTx, err = redeemPtx.B64Encode()
	if err != nil {
		return "", err
	}

	signedRedeemTx, err := h.arkClient.SignTransaction(ctx, redeemTx)
	if err != nil {
		return "", err
	}

	if _, _, err := h.transportClient.SubmitRedeemTx(ctx, signedRedeemTx); err != nil {
		return "", err
	}

	return txid, nil
}

func (h *SwapHandler) ListVHTLC(ctx context.Context, vhtlcAddress string) ([]client.Vtxo, error) {

	// Get vtxos for this address
	vtxos, _, err := h.transportClient.ListVtxos(ctx, vhtlcAddress)
	if err != nil {
		return nil, err
	}

	return vtxos, nil
}
